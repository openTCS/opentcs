// SPDX-FileCopyrightText: The openTCS Authors
// SPDX-License-Identifier: CC-BY-4.0

== Reference

=== System requirements

openTCS does not come with any specific hardware requirements.
CPU power and RAM capacity highly depend on the use case, e.g. the size and complexity of the driving course and the number of vehicles managed.
Some kind of networking hardware -- in most cases simply a standard Ethernet controller -- is required for communicating with the vehicles (and possibly other systems, like a warehouse management system).

To run openTCS, a Java Runtime Environment (JRE) version 21 is required.
(The directory `bin` of the installed JRE, for example `C:\Program Files\Eclipse Adoptium\jdk-21.0.3.9-hotspot\bin`, should be included in the enviroment variable PATH to be able to use the included start scripts.)

IMPORTANT: Due to a limitation in a software library used by openTCS (namely: Docking Frames), some JREs are currently not compatible with openTCS.
This is true e.g. for the JRE provided by Oracle.
The recommended JRE to use is the one provided by the https://adoptium.net/[Adoptium project].

=== System components and structure

openTCS consists of the following components running as separate processes and working together in a client-server architecture:

* Kernel (server process), running vehicle-independent strategies and drivers for controlled vehicles
* Clients
** Model editor for modelling the plant model
** Operations desk for visualizing the plant model during plant operation
** Kernel control center for controlling and monitoring the kernel, e.g. providing a detailed view of vehicles/their associated drivers
** Arbitrary clients for communicating with other systems, e.g. for process control or warehouse management

.openTCS system overview
image::system_overview.png[]

The purpose of the openTCS kernel is to provide an abstract driving model of a transportation system/plant, to manage transport orders and to compute routes for the vehicles.
Clients can communicate with this server process to, for instance, modify the plant model, to visualize the driving course and the processing of transport orders and to create new transport orders.

Three major strategy modules within the kernel implement processing of transport orders:

* A dispatcher that decides which transport order should be processed by which vehicle.
  Additionally, it needs to decide what vehicles should do in certain situation, e.g. when there aren't any transport orders or when a vehicle is running low on energy.
* A router which finds optimal routes for vehicles to reach their destinations.
* A scheduler that manages resource allocations for traffic management, i.e. to avoid vehicles crashing into each other.

The openTCS distribution comes with default implementations for each of these strategies.
These implementations can be easily replaced by a developer to adapt to environment-specific requirements.

The driver framework that is part of the openTCS kernel manages communication channels and associates vehicle drivers with vehicles.
A vehicle driver is an adapter between kernel and vehicle and translates each vehicle-specific communication protocol to the kernel's internal communication schemes and vice versa.
Furthermore, a driver may offer low-level functionality to the user via the kernel control center client, e.g. manually sending telegrams to the associated vehicle.
By using suitable vehicle drivers, vehicles of different types can be managed simultaneously by a single openTCS instance.

The model editor client that is part of the openTCS distribution allows editing of plant models, which can be loaded into the kernel.
This includes, for instance, the definition of load-change stations, driving tracks and vehicles.

The operations desk client that is part of the openTCS distribution is used to display the transportation system's general state and any active transport processes, and to create new transport orders interactively.

The kernel control center client that is part of the openTCS distribution allows controlling and monitoring the kernel.
Part of that is assigning vehicle drivers to vehicles and controlling them by enabling the communication and monitoring them by displaying vehicle state information, for instance.

Other clients, e.g. to control higher-level plant processes, can be implemented and attached.
For Java clients, the openTCS kernel provides an interface based on Java RMI (Remote Method Invocation).
Additionally, openTCS provides a web API for creating and withdrawing transport orders and retrieving transport order status updates.

=== Plant model elements

In openTCS, a plant model consists of a set of the following elements.
The attributes of these elements that are relevant for the plant model, e.g. the coordinates of a point or the length of a path, can be edited using the model editor client.

==== Point

Points are logical mappings of discrete vehicle positions in the driving course.
In plant operation mode, vehicles are ordered (and thus move) from one point to another in the model.
A point carries the following attributes:

* A _type_, which is one of these:
** _Halt position_:
   Indicates a position at which a vehicle may halt temporarily while processing an order, e.g. for executing an operation.
   The vehicle is expected to report in when it arrives at such a position.
   It may not remain here for longer than necessary, though.
   Halt position is the default type for points when modelling with the model editor client.
** _Park position_:
   Indicates a position at which a vehicle may halt for longer periods of time when it is not processing orders.
   The vehicle is also expected to report in when it arrives at such a position.
* A _position_, i.e. the point's coordinates in the plant's coordinate system.
* A _vehicle orientation angle_, which expresses the vehicle's assumed/expected orientation while it occupies the point.
* A set of _vehicle envelopes_ describing the areas occupied by vehicles located at the point.
* A _maximum vehicle bounding box_ describing the maximum bounding box that a vehicle located at the point may have (see <<Bounding box>> for more information).

NOTE: In openTCS, an angle of 0 degrees is at the 3 o'clock position, and a positive value indicates a counter-clockwise rotation.

===== Bounding box

.A bounding box in openTCS
image::bounding-box.drawio.png[]

A bounding box is characterised by a reference point that is -- by default -- located in the center of the bounding box's base (i.e. at height 0), named _base center_ for the remainder of this section.
The length and width of the bounding box are symmetrical in relation to the base center and the height is measured from the base of the bounding box.

Optionally, a reference point offset describes the position of the reference point in relation to the base center.
The coordinates of the reference point refer to a coordinate system whose origin is located at the base center and whose axes run along the longitudinal and transverse axes of the bounding box -- i.e. the x-axis runs along the length and the y-axis along the width of the bounding box.

For a vehicle, the bounding box is oriented so that its longitudinal axis runs parallel to the longitudinal axis of the vehicle.
For the reference point offset, positive x values indicate an offset in the forward direction of the vehicle, positive y values an offset towards the left-hand side.
As an example, a vehicle's physical reference point -- i.e. the point which its reported coordinates refer to -- and the reference point of its bounding box are probably always aligned.

For a point, the bounding box is oriented according to the orientation angle of the point so that the longitudinal axis of the bounding box runs parallel to the longitudinal axis of a vehicle located at the point.
For the reference point offset, positive x values indicate an offset in the forward direction of the vehicle, positive y values an offset towards the left-hand side.

The following figure shows examples of bounding boxes for a vehicle (on the left) and a point (on the right).
(Although a bounding box is three-dimensional in openTCS, the example bounding boxes shown here are only two-dimensional for an easy-to-understand visualisation.)

.Bounding boxes for vehicles and points
image::bounding-box-for-vehicle-and-point.drawio.png[]

In both cases, the blue dots represent the base centers of the respective bounding boxes and the green dots represent their reference points.
The dashed line represents the perimeter of the respective bounding box.
On the right, the orange dot represents the actual plant model point.
In the example above, the bounding boxes have the following properties:

[cols="1,1,1,1,1,1", options="header"]
|===
|Element
|Length [mm]
|Width [mm]
|Height [mm]
|Reference offset x [mm]
|Reference offset y [mm]

|Vehicle
|1100
|700
|_omitted_
|-300
|0

|Point
|1700
|1100
|_omitted_
|-500
|-100
|===

As an additional example, the following figure shows the bounding boxes in relation to each other and what it would look like if the vehicle was located at the point.
(Note that the reference points of both bounding boxes are aligned.)

.Relation of vehicle and point bounding boxes
image::bounding-box-vehicle-on-point.drawio.png[]

In this example, the point's bounding box encloses the vehicle's bounding box completely.
However, there may be situations where this is not the case and where the vehicle's bounding box would protrude beyond one or more sides of the point's bounding box.
To prevent a vehicle from being sent to a point in such situations, the router provides a dedicated cost function -- see <<Default router>>.

==== Path

Paths are connections between points that are navigable for vehicles.
A path's main attributes, next to its source and destination point, are:

* Its _length_, which may be relevant information for a vehicle in plant operation mode.
  Depending on the router configuration, it may also be used for computing routing costs/finding an optimal route to a destination point.
* A _maximum velocity_ and _maximum reverse velocity_, which may be relevant information for a vehicle in plant operation mode.
  Depending on the router configuration, it may also be used for computing routing costs/finding an optimal route to a destination point.
* A _locked_ flag, which, when set, tells the router that the path may not be used when computing routes for vehicles.
* A sequence of _peripheral operations_ describing operations that are to be performed by peripheral devices (in their given order) when a vehicle traverses the path.
* A set of _vehicle envelopes_ describing the areas occupied by vehicles traversing the path.

===== Peripheral operation

A peripheral operation's attributes are:

* A reference to the _location_ representing the peripheral device by which the operation is to be performed -- see <<Location>>.
* The actual _operation_ to be performed by the peripheral device.
* An _execution trigger_ defining the moment at which the operation is to be performed.
  The supported values are:
  ** `AFTER_ALLOCATION`: The execution of the operation should be triggered after a vehicle _has allocated_ the path.
  ** `AFTER_MOVEMENT`: The execution of the operation should be triggered after a vehicle _has traversed_ the path.
* A _completion required_ flag, which, when set, requires the operation to be completed to allow a vehicle to continue driving.
  This flag works in combination with the execution trigger.
  With the `AFTER_ALLOCATION` execution trigger and the completion required flag set to `true`, a vehicle has to wait at the path's source point until the operation is completed.
  With the `AFTER_MOVEMENT` execution trigger and the completion required flag set to `true`, a vehicle has to wait at the path's destination point until the operation is completed.

==== Location

Locations are markers for points at which vehicles may execute special operations (load or unload cargo, charge their battery etc.).
A location's attributes are:

* Its _type_, basically defining which operations are allowed at the location -- see <<Location type>>.
* A set of _links_ to points that the location can be reached from.
  To be of any use for vehicles in the plant model, a location needs to be linked to at least one point.
* A _locked_ flag, which, when set, tells the dispatcher that transport orders requiring an operation at the location may not be assigned to vehicles.

Additionally, locations can map peripheral devices for the purpose of communicating with them and allowing vehicles to interact with them (e.g. opening/closing fire doors along paths).
See <<Adding and configuring peripheral devices>> for details on how to add and configure peripheral devices.

==== Location type

Location types are abstract elements that group locations.
A location type has only two relevant attributes:

* A set of _allowed/supported vehicle operations_, defining which operations a vehicle may execute at locations of this type.
* A set of _allowed/supported peripheral operations_, defining which operations peripheral devices mapped to locations of this type may execute.

==== Vehicle

Vehicles map physical vehicles for the purpose of communicating with them and visualizing their positions and other characteristics.
A vehicle provides the following attributes:

* A set of energy level thresholds, which is composed as follows:
** A _critical energy level_, which is the threshold below which the vehicle's energy level is considered critical.
   This value may be used at plant operation time to decide when it is crucial to recharge a vehicle's energy storage.
** A _good energy level_, which is the threshold above which the vehicle's energy level is considered good.
   This value may be used at plant operation time to decide when it is unnecessary to recharge a vehicle's energy storage.
   When configuring this value, it must be greater than or equal to the _critical energy level_.
** A _sufficiently recharged energy level_, which is the threshold above which the vehicle is considered sufficiently recharged.
   This value may be used at plant operation time to decide when a vehicle may stop charging.
** A _fully recharged energy level_, which is the threshold above which the vehicle is considered being fully recharged.
   This value may be used at plant operation time to decide when a vehicle should stop charging.
   When configuring this value, it must be greater than or equal to the _sufficiently recharged energy level_.
* A _maximum velocity_ and _maximum reverse velocity_.
  Depending on the router configuration, it may be used for computing routing costs/finding an optimal route to a destination point.
* An _integration level_, indicating how far the vehicle is currently allowed to be integrated into the system.
  A vehicle's integration level can only be adjusted with the operations desk client, not with the model editor client.
  A vehicle can be
  ** ..._ignored_:
     The vehicle and its reported position will be ignored completely, thus the vehicle will not be displayed in the operations desk.
     The vehicle is not available for transport orders.
  ** ..._noticed_:
     The vehicle will be displayed at its reported position in the operations desk, but no resources will be allocated in the system for that position.
     The vehicle is not available for transport orders.
  ** ..._respected_:
     The resources for the vehicle's reported position will be allocated.
     The vehicle is not available for transport orders.
  ** ..._utilized_:
     The vehicle is available for transport orders and will be utilized by the openTCS.
* A _paused_ flag, indicating whether the vehicle is currently paused or not.
  A vehicle that is paused is supposed not to move/operate.
  In case it is currently moving when its paused flag is set, it is expected to stop as soon as possible.
  Some vehicle types may not support stopping before reaching their movement commands' destination.
  In such cases, openTCS will still ensure no further movement commands are sent to vehicles as long as they are paused.
* A set of _acceptable transport order types_, each consisting of a name and a priority, which are used for filtering transport orders (by their type) and sorting them (by their priority) when assigning transport orders to vehicles.
  With a vehicle's acceptable transport order types, a lower value indicates a higher priority.
  Also see <<Transport order>>.
* A _route color_, which is the color used for visualizing the route the vehicle is taking to its destination.
* An _envelope key_, indicating which envelopes (defined at points and paths) should be considered for the vehicle.
* A _bounding box_ describing the physical dimensions of the vehicle (see <<Bounding box>> for more information).

==== Block

Blocks (or block areas) are areas for which special traffic rules may apply.
They can be useful to prevent deadlock situations, e.g. at path intersections or dead ends.
A block has two relevant attributes:

* A set of _members_, i.e. resources (points, paths and/or locations) that the block is composed of.
* A _type_, which determines the rules for entering a block:
** _Single vehicle only_:
   The resources aggregated in this block can only be used by a single vehicle at the same time.
   This is the default type for blocks when modelling with the model editor client.
** _Same direction only_:
   The resources aggregated in this block can be used by multiple vehicles at the same time, but only if they traverse the block in the same direction.

NOTE: The direction in which a vehicle traverses a block is determined using the first allocation request containing resources that are part of the block -- see <<Default scheduler>>.
For the requested resources (usually a point and a path) the path is checked for a property with the key `tcs:blockEntryDirection`.
The property's value may be an arbitrary character string (including the empty string).
If there is no such property the path's name is being used as the direction.

==== Layer

Layers are abstract elements that group points, paths, locations and links.
They can be useful for modelling complex plants and dividing plant sections into logical groups (e.g. floors in a multi-floor plant).
A layer has the following properties:

* An _active_ flag, which indicates whether a layer is currently set as the active (drawing) layer.
  There can only be one active layer at a time.
  This property is shown only in the model editor client.
* A _visible_ flag, which indicates whether a layer is shown or hidden.
  When a layer is hidden, the model elements it contains are not displayed.
* A descriptive _name_.
* A _group_, that the layer is assigned to -- see <<Layer group>>.
  A layer can only be assigned to one layer group at a time.
* A _group visible_ flag, which indicates whether the layer group the layer is assigned to is shown or hidden -- see <<Layer group>>.

In addition to the properties listed above, layers also have an ordinal number (which is not displayed) that defines the order of the layers in relation to each other.
The order of the layers is represented by the order of the entries in the "Layers" table in the Model Editor and the Operations Desk clients.
The topmost entry corresponds to the topmost layer (which is displayed above all other layers) and the bottommost entry corresponds to the bottommost layer (which is displayed below all other layers).

==== Layer group

Layer groups are abstract elements that group layers.
A layer group has the following properties:

* A descriptive _name_.
* A _visible_ flag, which indicates whether the layer group is shown or hidden.
  When a layer group is hidden, the model elements contained in all layers assigned to it are not displayed.
  The visibility state of a layer group doesn't affect the visibility state of the layers assigned to it.

=== Plant operation elements

Transport orders and order sequences are elements that are available only at plant operation time.
Their attributes are primarily set when the respective elements are created.

==== Transport order

A transport order is a parameterized sequence of movements and operations to be processed by a vehicle.
When creating a transport order, the following attributes can be set:

* A sequence of _destinations_ that the processing vehicle must process (in their given order).
  Each destination consists of a location that the vehicle must travel to and an operation that it must perform there.
* An optional _deadline_, indicating when the transport order is supposed to have been processed.
* An optional _type_, which is a string used for filtering vehicles that may be assigned to the transport order.
  A vehicle may only be assigned to a transport order if the order's type is in the vehicle's set of acceptable order types.
  (Examples for potentially useful types are `"Transport"` and `"Maintenance"`.)
* An optional _intended vehicle_, telling the dispatcher to assign the transport order to the specified vehicle instead of selecting one automatically.
* A _dispensable_ flag, indicating whether the transport order may be withdrawn automatically, primarily to make the processing vehicle available for another transport order.
  Orders that are usually marked as dispensable are parking orders, for instance:
  when a vehicle is on its way to a parking position and a new transport order becomes available for it, it makes sense to assign the new transport order to the vehicle rather sooner than later, skipping the rest of the way to the parking position.
* An optional set of _dependencies_, i.e. references to other transport orders that need to be processed before the transport order.
  Dependencies are transitive, meaning that if order A depends on order B and order B depends on order C, C must be processed first, then B, then A.
  As a result, dependencies are a means to impose an order on sets of transport orders.
  (They do not, however, implicitly require all the transport orders to be processed by the same vehicle.
  This can optionally be achieved by also setting the _intended vehicle_ attribute of the transport orders.)
  The following image shows an example of dependencies between multiple transport orders:

.Transport order dependencies
image::transportorder_dependencies_example.png[]

==== Order sequence

NOTE: The operations desk application currently does not provide a way to create order sequences.
They can only be created programmatically, using dedicated clients that are not part of the openTCS distribution.

An order sequence describes a process spanning multiple transport orders which are to be executed subsequently -- in the exact order defined by the sequence -- by a single vehicle.
Once a vehicle is assigned to an order sequence, it may not process transport orders not belonging to the sequence, until the latter is finished.

Order sequences are useful when a complex process to be executed by one and the same vehicle cannot be mapped to a single transport order.
This can be the case, for instance, when the details of some steps in the process become known only after processing previous steps.

An order sequence carries the following attributes:

* A sequence of _transport orders_, which may be extended as long the complete flag (see below) is not set, yet.
* A _complete_ flag, indicating that no further transport orders will be added to the sequence.
  This cannot be reset.
* A _failure fatal_ flag, indicating that, if one transport order in the sequence fails, all orders following it should immediately be considered as failed too, unless the failed transport order is marked as dispensable.
* A _finished_ flag, indicating that the order sequence has been processed (and the vehicle is not bound to it, anymore).
  An order sequence can only be marked as finished if it has been marked as complete before.
* A set of _order types_ -- see <<Transport order>>.
  Only transport orders whose type is included in the set of order types of an order sequence can be added to it.
* An optional _intended vehicle_, telling the dispatcher to assign the order sequence to the specified vehicle instead of selecting one automatically.
  If set, all transport orders added to the order sequence must carry the same intended vehicle value.

.An order sequence
image::ordersequence_example.png[]

==== Peripheral job

A peripheral job describes an operation to be performed by a peripheral device.
A peripheral job carries the following attributes:

* An _operation_ to be performed by a peripheral device -- see <<Peripheral operation>>.
* A _reservation token_ that may be used to reserve a peripheral device.
  A peripheral device that is reserved for a specific token can only process jobs which match that reservation token -- see <<Reservation token>>.
* An optional _related vehicle_ referencing the vehicle by which the peripheral job was created.
* An optional _related transport order_ referencing the transport order in which context the peripheral job was created.

=== Common element attributes

==== Unique name

Every plant model and plant operation element has a unique name identifying it in the system, regardless of what type of element it is.
Two elements may not be given the same name, even if e.g. one is a point and the other one is a transport order.

==== Generic properties

In addition to the listed attributes, it is possible to define arbitrary properties as key-value pairs for all driving course elements, which for example can be read and evaluated by vehicle drivers or client software.
Both the key and the value can be arbitrary character strings.
For example, a key-value pair `"IP address"`:``"192.168.23.42"`` could be defined for a vehicle in the model, stating which IP address is to be used to communicate with the vehicle; a vehicle driver could now check during runtime whether a value for the key `"IP address"` was defined, and if yes, use it to automatically configure the communication channel to the vehicle.
Another use for these generic attributes can be vehicle-specific actions to be executed on certain paths in the model.
If a vehicle should, for instance, issue an acoustic warning and/or turn on the right-hand direction indicator when currently on a certain path, attributes with the keys `"acoustic warning"` and/or `"right-hand direction indicator"` could be defined for this path and evaluated by the respective vehicle driver.

=== Default strategies

openTCS comes with a default implementation for each of the strategy modules.
These implementations can easily be replaced to adapt to project-specific requirements.
(See developer's guide.)

==== Default dispatcher

When either a transport order or a vehicle becomes available, the dispatcher needs to decide what should happen with which transport order and which vehicle should do what.
To make this decision, the default dispatcher takes the following steps:

. New transport orders are prepared for processing.
  This includes checking general routability and unfinished dependencies.
. Updates of processes that are currently active are performed.
  This includes:
** Withdrawals of transport orders
** Successful completion of transport orders
** Assignment of subsequent transport orders for vehicles that are processing order sequences
. Vehicles that are currently unoccupied are assigned to processable transport orders, if possible.
** Criteria for a vehicle to be taken into account are:
*** It must be at a known position in the driving course.
*** It may not be assigned to a transport order, or the assigned transport order must be _dispensable_.
    That is the case with parking orders, for instance, or with recharging orders if the vehicle's energy level is not critical.
*** It may not be processing an order sequence; alternatively, the currently processed transport order must be _dispensable_ and must be the last order in an order sequence that is marked as _complete_.
*** Its energy level must not be critical.
    (Vehicles with critical energy level are taken into account only for transport orders with which the first destination operation is a recharge operation.)
** Criteria for a transport order to be taken into account are:
*** It must be generally dispatchable.
*** It must not be part of an order sequence that is already being processed by a vehicle.
** The assignment mechanics are as following:
*** If there are less unoccupied vehicles than processable transport orders, the list of vehicles is sorted by configurable criteria.
    The default dispatcher then iterates over the sorted list and, for every vehicle, finds all orders processable by it, computes the required routes, sorts the candidates by configurable criteria and assigns the first one.
*** If there are less processable transport orders than unoccupied vehicles, the list of transport orders is sorted by configurable criteria.
    The default dispatcher then iterates over the sorted list and, for every transport order, finds all vehicles that could process it, computes the required routes, sorts the candidates by configurable criteria and assigns the first one.
*** For configuration options regarding the sorting criteria, see <<Default dispatcher configuration entries>>.
. Vehicles that are still unoccupied are sent to a recharging location, if possible.
** Criteria for a vehicle to be taken into account are:
*** It must be at a known position in the driving course.
*** Its energy level is _degraded_.
. Vehicles that are still unoccupied are sent to a parking position, if possible.
** Criteria for a vehicle to be taken into account are:
*** It must be at a known position in the driving course.
*** It must not be at a parking position already.

===== Default parking position selection

When sending a vehicle to a parking position, the closest (according to the router) unoccupied position is selected by default.
It is possible to assign fixed positions to vehicles instead, by setting properties with the following keys on them:

* `tcs:preferredParkingPosition`:
  Expected to be the name of a point in the model.
  If this point is already occupied, the closest unoccupied parking position (if any) is selected instead.
* `tcs:assignedParkingPosition`:
  Expected to be the name of a point in the model.
  If this point is already occupied, the vehicle is not sent to any other parking position, i.e. remains where it is.
  Takes precedence over `tcs:preferredParkingPosition`.

===== Optional parking position priorities

Optionally (see <<Default dispatcher configuration entries>> for how to enable it), parking positions may be explicitly prioritized, and vehicles can be reparked in a kind of "parking position queues".
This can be desirable e.g. to park vehicles close to locations that are frequent first destinations for transport orders.
(For example, imagine a plant in which goods are transported from A to B all the time.
Even if there currently aren't any transport orders, it might nevertheless be a good idea to prefer parking positions near A to reduce reaction times when transport orders arrive.)

To assign a priority to a parking position, set a property with the key `tcs:parkingPositionPriority` on the point.
The property's value should be a decimal integer, with lower values resulting in a higher priority for the parking position.

===== Default recharging location selection

When sending a vehicle to a recharge location, the closest (according to the router) unoccupied position is selected by default.
It is possible to assign fixed positions to vehicles instead, by setting properties with the following keys on them:

* `tcs:preferredRechargeLocation`:
  Expected to be the name of a location.
  If this location is already occupied, the closest unoccupied recharging location (if any) is selected instead.
* `tcs:assignedRechargeLocation`:
  Expected to be the name of a location.
  If this location is already occupied, the vehicle is not sent to any other recharging location.
  Takes precedence over `tcs:preferredRechargeLocation`.

===== Immediate transport order assignment

In addition to the _implicit_ assignment of transport orders according to the flow and rules described in the previous sections, transport orders can also be assigned _explicitly_ (i.e. immediately).
Immediate assignment of transport orders is supported for transport orders that have their intended vehicle set.
This can be helpful in situations where a transport order and its intended vehicle are generally in a state where an assignment would be possible, but is prevented by certain filter criteria in the regular dispatcher flow.

Although the immediate assignment of transport orders bypasses some of the filter criteria in the regular dispatcher flow, it works only in specific situations.
Regarding the transport order's state:

* The transport order's state must be `DISPATCHABLE`.
* The transport order must not be part of an order sequence.
* The transport order's intended vehicle must be set.

As for the (intended) vehicle's state:

* The vehicle's processing state must be `IDLE`.
* The vehicle's state must be `IDLE` or `CHARGING`.
* The vehicle's integration level must be `TO_BE_UTILIZED`.
* The vehicle must be reported at a known position.
* The vehicle must not process an order sequence.

NOTE: In addition to the state of the respective transport order and its intended vehicle, the dispatcher may have further implementation-specific reasons to reject an immediate assignment.

==== Default router

The default router finds the cheapest route from one position in the driving course to another one.
(It uses an implementation of link:https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm[Dijkstra's algorithm] to do that.)
It takes into account paths that have been locked, but not positions and/or assumed future behaviour of other vehicles.
As a result, it does not route around slower or stopped vehicles blocking the way.

===== Cost functions

The cost function used for evaluating the paths in the driving course can be selected via configuration.
(See <<Default router configuration entries>>, the relevant configuration entry is `defaultrouter.shortestpath.edgeEvaluators`.)
The following cost functions/configuration options are available:

* `DISTANCE` (default):
  Routing costs are equal to the paths' lengths.
* `TRAVELTIME`:
  Routing costs are computed as the expected time to travel on the paths (in seconds), i.e. as path length divided by maximum allowed vehicle speed.
* `EXPLICIT_PROPERTIES`:
  Routing costs for a vehicle on a path are taken from path properties with keys `tcs:routingCostForward<GROUP>` and `tcs:routingCostReverse<GROUP>`.
  The `<GROUP>` to be used is the vehicle's routing group (see <<Routing groups>>).
  As an example, if a vehicle's routing group is set to "Example", routing costs for this vehicle would be taken from path properties with keys `tcs:routingCostForwardExample` and `tcs:routingCostReverseExample`.
  This way, different routing costs can be assigned to a path, e.g. for different types of vehicles. +
  Note that, for this cost function to work properly, the values of the routing cost properties should be decimal integers.
  An exception to this is the string `Infinity`, which the property value can be set to, indicating that the path may not be used by vehicles of the respective routing group at all.
* `HOPS`:
  The routing costs for every path in the model is 1, which results in the route with the least paths/points being chosen.
* `BOUNDING_BOX`:
  Routing costs for a vehicle on a path are determined by comparing the vehicle's bounding box with the maximum allowed bounding box at the path's destination point -- see <<Bounding box>>.
  If the vehicle's bounding box protrudes beyond a destination point's bounding box, the routing costs for the corresponding path are considered infinitely high, indicating that the path may not be used by the vehicle at all.
  Otherwise, the routing costs for the corresponding path are 0.
  This can be used to prevent vehicles from being routed to/through points where there is insufficient space available.

Developers can integrate additional custom cost functions using the openTCS API.

More than one cost function can be selected in the configuration by listing them separated by commas.
The costs computed by the respective functions are then added up.
For example, when using `"DISTANCE, TRAVELTIME"`, costs for routes are computed as the sum of the paths' lengths and the time a vehicle needs to pass it.

NOTE: Adding distances to durations obviously does not make sense.
It is the user's responsibility to choose a configuration that is usable and appropriate for the respective use case.

===== Routing groups

It is possible to treat vehicles in a plant differently when computing their routes.
This may be desirable if they have different characteristics and actually have different optimal routes through the driving course.
For this to work, the paths in the model or the cost function used need to reflect this difference.
This isn't done by default -- the default router computes routes for all vehicles the same way unless told otherwise.
To let the router know that it should compute routes for a vehicle separately, set a property with the key `tcs:routingGroup` to an arbitrary string.
(Vehicles that have the same value set share the same routing table, and the empty string is the default value for all vehicles.)

===== Avoiding/Excluding resources when computing routes

When computing a route for a transport order, it is possible to define a set of resources (i.e., points, paths or locations) that should be avoided by vehicles processing the respective transport order.
For this, a property with the key `tcs:resourcesToAvoid` can be set on a transport order to a comma-separated list of resource names.

==== Default scheduler

The default scheduler implements a simple strategy for traffic management.
It does this by allowing only mutually exclusive use of resources in the plant model (points, paths and locations), as described below.

===== Allocating resources

When an allocation of a set of resources for a vehicle is requested, the scheduler performs the following checks to determine whether the allocation can be granted immediately:

. Check if the vehicle requesting the resources is _not_ paused.
. Check if the requested resources are generally available for the vehicle.
. Check if the requested resources are part of a block with the type `SINGLE_VEHICLE_ONLY`.
  If not, skip this check.
  If yes, expand the requested resource set to the effective resource set and check if the expanded resources are available for the vehicle.
. Check if the requested resources are part of a block with the type `SAME_DIRECTION_ONLY`.
  If not, skip this check.
  If yes, check if the direction in which the vehicle intends to traverse the block is the same the block is already being traversed by other vehicles.
. Check if the areas related to the requested resources are available for the vehicle and not allocated by other vehicles (provided that the vehicle requesting the resources references an envelope key and the requested resources define vehicle envelopes with that key).
  In case requested resources or resources occupied by other vehicles are part of blocks, the checked areas are expanded to include the envelopes of all resources in these blocks (while considering the envelope keys of the respective vehicles involved).

If all checks succeed, the allocation is made.
If any of the checks fail, the allocation is queued for later.

===== Freeing resources

Whenever resources are freed (e.g. when a vehicle has finished its movement to the next point and the vehicle driver reports this to the kernel), the allocations waiting in the queue are checked (in the order the requests happened).
Any allocations that can now be made are made.
Allocations that cannot be made are kept waiting.

===== Fairness of scheduling

This strategy ensures that resources are used when they are available.
It does not, however, strictly ensure fairness/avoid starvation:
Vehicles waiting for allocation of a large resource set may theoretically wait forever if other vehicles can keep allocating subsets of those resources continuously.
Such situations are likely a hint at problems in the plant model graph's topology, which is why this deficiency is considered acceptable for the default implementation.

==== Default peripheral job dispatcher

When either a peripheral job or a peripheral device becomes available, the peripheral job dispatcher needs to decide what should happen with which peripheral job and which peripheral device should do what.
To make this decision, the default peripheral job dispatcher takes the following steps:

. Peripheral devices that are currently unoccupied but have their reservation token set are assigned to processable peripheral jobs, if possible.
** Criteria for a peripheral device to be taken into account are:
*** It must not be assigned to a peripheral job.
*** It must have its reservation token set.
** Criteria for a peripheral job to be taken into account are:
*** It must match the reservation token of a peripheral device.
*** It must be processable by a peripheral device.
** If there are multiple peripheral jobs that meet these criteria, the oldest one according to the creation time is assigned first.
. Peripheral devices that could not be assigned to a peripheral job with a matching reservation token have their reservation released.
** The release of reserved peripheral devices is performed via a replaceable strategy.
   The default strategy releases peripheral devices according to the following rules:
*** A peripheral device's state must be `IDLE`.
*** A peripheral device's processing state must be `IDLE`.
*** A peripheral device's reservation token must be set.
. Peripheral devices that are currently unoccupied and do not have their reservation token set are assigned to processable peripheral jobs, if possible.
** Criteria for a peripheral device to be taken into account are:
*** It must not be assigned to a peripheral job.
*** It must not have its reservation token set.
** Criteria for a peripheral job to be taken into account are:
*** It must be generally available to be processed by a peripheral device.
*** It must be processable by a peripheral device.
** The selection of a peripheral job for a peripheral device is performed via a replaceable strategy.
   The default strategy selects peripheral jobs according to the following rules:
*** The location of a peripheral job's operation must match the given location.
*** If there are multiple peripheral jobs that meet these criteria, the oldest one according to the creation time is selected.

===== Reservation token

As described above, reservation tokens are relevant for the assignment of peripheral jobs to peripheral devices.
This section describes the different types of reservation tokens:

. Reservation tokens for transport orders.
** Optionally, transport orders can be provided with a reservation token.
** If a transport order's reservation token is set, it is used for peripheral jobs that are created in the context of the transport order (i.e., for peripheral jobs that are created implicitly by vehicles processing a transport order - see <<Implicit creation of peripheral jobs>>).
. Reservation tokens for peripheral jobs.
** Peripheral jobs must always be provided with a reservation token.
** For peripheral jobs that are created implicitly by vehicles as they traverse paths that have peripheral operations defined on them, the reservation token is set to
*** the reservation token of the transport order the corresponding vehicle is processing
*** or the name of the vehicle, if the reservation token on the transport order is not set.
. Reservation tokens for locations that represent peripheral devices.
** Initially, the reservation token of a location representing a peripheral device is not set.
   This indicates that the peripheral device is generally available to accept a peripheral job with any reservation token.
** Once the peripheral device is assigned a peripheral job, the location's reservation token is set to the peripheral job's reservation token.
   As a result, the peripheral device is only available for peripheral jobs with the same reservation token until the peripheral device's reservation is released (i.e., until the peripheral device's reservation token is reset).

=== Configuring openTCS

==== Application language

By default, all openTCS applications with user interfaces display texts in English language.
The applications are prepared for internationalization, though, and can be configured to display texts in a different language, provided there is a translation for it.
The openTCS distribution comes with the default (English) language and a German translation.
Additional translations can be integrated -- how this is done is described in the Developer's Guide.

For setting the language, each application has a configuration entry that needs to be set to a _language tag_ for the language to use.
(See <<Kernel Control Center application configuration entries>>, <<Model Editor application configuration entries>> and <<Operations Desk application configuration entries>>.)
Examples for language tags are:

* "en" for English
* "de" for German
* "no" for Norwegian
* "zh" for Chinese

By default, the configuration entries are set to "en", resulting in English texts.
Since a German translation is included, you can switch e.g. the Operations Desk application to German by setting its `locale` configuration entry to "de".
(Note that the application needs to be restarted for this.)

Configuring an application to use a language for which there is no translation will result in the default (English) language to be used.

==== Kernel configuration

The kernel application reads its configuration data from the following files:

. `config/opentcs-kernel-defaults-baseline.properties`,
. `config/opentcs-kernel-defaults-custom.properties` and
. `config/opentcs-kernel.properties`.

The files are read in this order, and configuration values set in one file can be overridden in any subsequent one.
For users, it is recommended to leave the first two files untouched and set overriding values and project-specific configuration data in `opentcs-kernel.properties` only.

===== Kernel application configuration entries

The kernel application itself can be configured using the following configuration entries:

include::{configdoc}/KernelApplicationConfigurationEntries.adoc[]

===== Order pool configuration entries

The kernel's transport order pool can be configured using the following configuration entries:

include::{configdoc}/OrderPoolConfigurationEntries.adoc[]

===== Default dispatcher configuration entries

The default dispatcher can be configured using the following configuration entries:

include::{configdoc}/DefaultDispatcherConfigurationEntries.adoc[]

===== Default router configuration entries

The default router can be configured using the following configuration entries:

include::{configdoc}/DefaultRouterConfigurationEntries.adoc[]

The shortest path algorithm can be configured using the following configuration entries:

include::{configdoc}/ShortestPathConfigurationEntries.adoc[]

The edge evaluator `EXPLICIT_PROPERTIES` can be configured using the following configuration entries:

include::{configdoc}/ExplicitPropertiesConfigurationEntries.adoc[]

===== Default peripheral job dispatcher configuration entries

The default peripheral job dispatcher can be configured using the following configuration entries:

include::{configdoc}/DefaultPeripheralJobDispatcherConfigurationEntries.adoc[]

===== Service web API configuration entries

The kernel's service web API can be configured using the following configuration entries:

include::{configdoc}/ServiceWebApiConfigurationEntries.adoc[]

===== RMI kernel interface configuration entries

The kernel's RMI interface can be configured using the following configuration entries:

include::{configdoc}/RmiKernelInterfaceConfigurationEntries.adoc[]

===== SSL server-side encryption configuration entries

The kernel's SSL encryption can be configured using the following configuration entries:

include::{configdoc}/KernelSslConfigurationEntries.adoc[]

===== Vehicle position resolver configuration entries

The vehicle position resolver can be configured using the following configuration entries:

include::{configdoc}/VehiclePositionResolverConfigurationEntries.adoc[]

===== Virtual vehicle configuration entries

The virtual vehicle (loopback communication adapter) can be configured using the following configuration entries:

include::{configdoc}/VirtualVehicleConfigurationEntries.adoc[]

===== Virtual peripheral configuration entries

The virtual peripheral (peripheral loopback communication adapter) can be configured using the following configuration entries:

include::{configdoc}/VirtualPeripheralConfigurationEntries.adoc[]

===== Watchdog configuration entries

The watchdog can be configured using the following configuration entries:

include::{configdoc}/WatchdogConfigurationEntries.adoc[]

==== Kernel Control Center configuration

The kernel control center application reads its configuration data from the following files:

. `config/opentcs-kernelcontrolcenter-defaults-baseline.properties`,
. `config/opentcs-kernelcontrolcenter-defaults-custom.properties` and
. `config/opentcs-kernelcontrolcenter.properties`.

The files are read in this order, and configuration values set in one file can be overridden in any subsequent one.
For users, it is recommended to leave the first two files untouched and set overriding values and project-specific configuration data in `opentcs-kernelcontrolcenter.properties` only.

===== Kernel Control Center application configuration entries

The kernel control center application itself can be configured using the following configuration entries:

include::{configdoc}/KernelControlCenterApplicationConfigurationEntries.adoc[]

===== SSL KCC-side application configuration entries

The kernel control center application's SSL connections can be configured using the following configuration entries:

include::{configdoc}/KccSslConfigurationEntries.adoc[]

==== Model Editor configuration

The model editor application reads its configuration data from the following files:

. `config/opentcs-modeleditor-defaults-baseline.properties`,
. `config/opentcs-modeleditor-defaults-custom.properties`,
. `config/opentcs-modeleditor.properties`.

The files are read in this order, and configuration values set in one file can be overridden in any subsequent one.
For users, it is recommended to leave the first two files untouched and set overriding values and project-specific configuration data in `opentcs-modeleditor.properties` only.

===== Model Editor application configuration entries

The model editor application itself can be configured using the following configuration entries:

include::{configdoc}/ModelEditorConfigurationEntries.adoc[]

===== SSL model editor-side application configuration entries

The model editor application's SSL connections can be configured using the following configuration entries:

include::{configdoc}/PoSslConfigurationEntries.adoc[]

===== Model Editor element naming scheme configuration entries

The model editor application's element naming schemes can be configured using the following configuration entries:

include::{configdoc}/PO_ElementNamingSchemeConfigurationEntries.adoc[]

==== Operations Desk configuration

The operations desk application reads its configuration data from the following files:

. `config/opentcs-operationsdesk-defaults-baseline.properties`,
. `config/opentcs-operationsdesk-defaults-custom.properties`,
. `config/opentcs-operationsdesk.properties`.

The files are read in this order, and configuration values set in one file can be overridden in any subsequent one.
For users, it is recommended to leave the first two files untouched and set overriding values and project-specific configuration data in `opentcs-operationsdesk.properties` only.

===== Operations Desk application configuration entries

The operations desk application itself can be configured using the following configuration entries:

include::{configdoc}/OperationsDeskConfigurationEntries.adoc[]

===== SSL operation desk-side application configuration entries

The operation desk application's SSL connections can be configured using the following configuration entries:

include::{configdoc}/PoSslConfigurationEntries.adoc[]
