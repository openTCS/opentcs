// SPDX-FileCopyrightText: The openTCS Authors
// SPDX-License-Identifier: CC-BY-4.0

== How-to Guides

=== Generating an integration project

openTCS integration projects for customer- or plant-specific distributions often have a very similar structure.
The openTCS distribution provides a way to easily generate such integration projects.
This way, a developer can get started with customizing and extending openTCS components quickly.

To generate a template/skeleton for a new integration project, do the following:

1. Download and unzip the integration project example from the openTCS homepage.
2. Execute the following command from the example project's root directory:
`gradlew cloneProject`

The integration project will be generated in the `build/` directory.
(Make sure you copy it somewhere else before running the example project's `clean` task the next time.)

The project and the included classes will have generic names.
You can adjust their names by setting a couple of properties when running the above command.
The following properties are looked at:

* _integrationName_:
Used for the names of the project itself and the subprojects within it.
* _classPrefix_:
Used for some classes within the subprojects.

For instance, your command line could look like this:

[source, shell]
----
gradlew -PintegrationName=MyGreatProject -PclassPrefix=Great cloneProject
----

This would include _MyGreatProject_ in the integration project name, and _Great_ in some class names.

IMPORTANT: Inserting your own source code into a copy of the baseline openTCS project instead of creating a proper integration project as described above is not recommended.
This is because, when integrating openTCS by copying its source code, you lose the ability to easily upgrade your code to more recent openTCS versions (for bugfixes or new features).

=== Acquiring service objects

To use the services in code running inside the kernel JVM, e.g. a vehicle driver, simply request an instance of e.g. `PlantModelService` to be provided via dependency injection.
You may also work with an instance of `InternalPlantModelService` here, which provides additional methods available only to kernel application components.

To access the services from another JVM, e.g. in a client that is supposed to create transport orders or to receive status updates for transport orders or vehicles, you need to connect to them via Remote Method Invocation (RMI).
The easiest way to do this is by creating an instance of the `KernelServicePortalBuilder` class and letting it build a `KernelServicePortal` instance for you.
(For now, there isn't much support for user management, so it is recommended to ignore the methods that require user credentials.)
After creating the `KernelServicePortal` instance, you can use it to get service instances and fetch kernel events from it.
See also the class documentation for `KernelServicePortalBuilder` in the base API's JavaDoc documentation.

// XXX Move this example into a test class.

[source, java]
----
KernelServicePortal servicePortal = new KernelServicePortalBuilder().build();

// Connect and log in with a kernel somewhere.
servicePortal.login("someHost", 1099);

// Get a reference to the plant model service...
PlantModelService plantModelService = servicePortal.getPlantModelService();
// ...and find out the name of the currently loaded model.
String modelName = plantModelService.getLoadedModelName();

// Poll events, waiting up to a second if none are currently there.
// This should be done periodically, and probably in a separate thread.
List<Object> events = servicePortal.fetchEvents(1000);
----

=== Working with transport orders

==== How to create a transport order

Create a list of destinations the vehicle is supposed to travel to.
Every destination is described by the name of the destination location in the plant model and an operation the vehicle is supposed to perform there:

[source, java]
----
include::{documentation-testSrc}/org/opentcs/documentation/developers_guide/CreateTransportOrderTest.java[tags=createTransportOrder_createDestinations, indent=0]
----

Put as many destinations into the list as necessary.
Then create a transport order description with a name for the new transport order and the list of destinations.

[source, java]
----
include::{documentation-testSrc}/org/opentcs/documentation/developers_guide/CreateTransportOrderTest.java[tags=createTransportOrder_createTransportOrderCreationTO, indent=0]
----

Optionally, express that the full name of the order should be generated by the kernel.
(If you do not do this, you need to ensure that the name of the transport order given above is unique.)

[source, java]
----
include::{documentation-testSrc}/org/opentcs/documentation/developers_guide/CreateTransportOrderTest.java[tags=createTransportOrder_setIncompleteName, indent=0]
----

Optionally, set more parameters for the transport order, e.g. set a deadline for the order or assign a specific vehicle to it:

[source, java]
----
include::{documentation-testSrc}/org/opentcs/documentation/developers_guide/CreateTransportOrderTest.java[tags=createTransportOrder_setMoreOptionalParameters, indent=0]
----

Get a `TransportOrderService` (see <<Acquiring service objects>>) and ask it to create a transport order using the given description:

[source, java]
----
include::{documentation-testSrc}/org/opentcs/documentation/developers_guide/CreateTransportOrderTest.java[tags=createTransportOrder_useServiceToCreateOrder, indent=0]
----

Optionally, get a `DispatcherService` and trigger the kernel's dispatcher explicitly to have it check for a vehicle that can process the transport order.
(You only need to do this if you need the dispatcher to be triggered immediately after creating the transport order.
If you do not do this, the dispatcher will still be triggered periodically.)

[source, java]
----
include::{documentation-testSrc}/org/opentcs/documentation/developers_guide/CreateTransportOrderTest.java[tags=createTransportOrder_triggerDispatcher, indent=0]
----

==== How to create a transport order that sends a vehicle to a point instead of a location

Create a list containing a single destination to a point, using `Destination.OP_MOVE` as the operation to be executed:

[source, java]
----
include::{documentation-testSrc}/org/opentcs/documentation/developers_guide/CreateTransportOrderTest.java[tags=createTransportOrderToPoint_createDestinations, indent=0]
----

Create a transport order description with a name for the new transport order and the (single-element) list of destinations:

[source, java]
----
include::{documentation-testSrc}/org/opentcs/documentation/developers_guide/CreateTransportOrderTest.java[tags=createTransportOrderToPoint_createTransportOrderCreationTO, indent=0]
----

Get a `TransportOrderService` (see <<Acquiring service objects>>) and ask it to create a transport order using the given description:

[source, java]
----
include::{documentation-testSrc}/org/opentcs/documentation/developers_guide/CreateTransportOrderTest.java[tags=createTransportOrderToPoint_useServiceToCreateOrder, indent=0]
----

Optionally, get a `DispatcherService` and trigger the kernel's dispatcher explicitly to have it check for a vehicle that can process the transport order.
(You only need to do this if you need the dispatcher to be triggered immediately after creating the transport order.
If you do not do this, the dispatcher will still be triggered periodically.)

[source, java]
----
include::{documentation-testSrc}/org/opentcs/documentation/developers_guide/CreateTransportOrderTest.java[tags=createTransportOrderToPoint_triggerDispatcher, indent=0]
----

==== How to work with order sequences

An order sequence can be used to force a single vehicle to process multiple transport orders in a given order.
Some rules for using order sequences are described in the API documentation for `OrderSequence`, but here is what you would do in general.
First, create an order sequence description, providing a name:

[source, java]
----
include::{documentation-testSrc}/org/opentcs/documentation/developers_guide/CreateTransportOrderSequenceTest.java[tags=createOrderSequence_createOrderSequenceCreationTO, indent=0]
----

Optionally, express that the full name of the sequence should be generated by the kernel.
(If you do not do this, you need to ensure that the name of the order sequence given above is unique.)

[source, java]
----
include::{documentation-testSrc}/org/opentcs/documentation/developers_guide/CreateTransportOrderSequenceTest.java[tags=createOrderSequence_setIncompleteName, indent=0]
----

Optionally, set the sequence's failure-fatal flag:

[source, java]
----
include::{documentation-testSrc}/org/opentcs/documentation/developers_guide/CreateTransportOrderSequenceTest.java[tags=createOrderSequence_setFailureFatal, indent=0]
----

Get a `TransportOrderService` (see <<Acquiring service objects>>) and ask it to create an order sequence using the given description:

[source, java]
----
include::{documentation-testSrc}/org/opentcs/documentation/developers_guide/CreateTransportOrderSequenceTest.java[tags=createOrderSequence_useServiceToCreateSequence, indent=0]
----

Create a description for the transport order as usual, but set the wrapping sequence's name via `withWrappingSequence()` to associate the transport order with the order sequence.
Then, create the transport order using the `TransportOrderService`.

[source, java]
----
include::{documentation-testSrc}/org/opentcs/documentation/developers_guide/CreateTransportOrderSequenceTest.java[tags=createOrderSequence_createTransportOrder, indent=0]
----

Create and add more orders to the order sequence as necessary.
Eventually, set the order sequence's _complete_ flag to indicate that no further transport orders will be added to it:

[source, java]
----
include::{documentation-testSrc}/org/opentcs/documentation/developers_guide/CreateTransportOrderSequenceTest.java[tags=createOrderSequence_markSequenceComplete, indent=0]
----

As long as the sequence has not been marked as complete and finished completely, the vehicle selected for its first order will be tied to this sequence.
It will not process any orders not belonging to the same sequence until the whole sequence has been finished.

Once the _complete_ flag of the sequence has been set and all transport orders belonging to it have been processed, its _finished_ flag will be set by the kernel.

==== How to withdraw a transport order

To withdraw a transport order, get a `DispatcherService` (see <<Acquiring service objects>>) and ask it to withdraw the order, providing a reference to it:

[source, java]
----
include::{documentation-testSrc}/org/opentcs/documentation/developers_guide/WithdrawTransportOrderTest.java[tags=documentation_withdrawTransportOrder, indent=0]
----

The second argument indicates whether the vehicle should finish the movements it is already assigned to (`false`) or abort immediately (`true`).

==== How to withdraw a transport order via a vehicle reference

To withdraw the transport order that a specific vehicle is currently processing, get a `DispatcherService` (see <<Acquiring service objects>>) and ask it to withdraw the order, providing a reference to the vehicle:

[source, java]
----
include::{documentation-testSrc}/org/opentcs/documentation/developers_guide/WithdrawTransportOrderTest.java[tags=documentation_withdrawTransportOrderByVehicle, indent=0]
----

The second argument indicates whether the vehicle should finish the movements it is already assigned to (`false`) or abort immediately (`true`).

=== Using the event bus

Each of the main openTCS applications -- Kernel, Kernel Control Center, Model Editor and Operations Desk -- provides an event bus that can be used to receive or emit event objects application-wide.
To acquire the respective application's event bus instance, request it to be provided via dependency injection.
Any of the following three variants of constructor parameters are equivalent:

[source, java]
----
public MyClass(@ApplicationEventBus EventHandler eventHandler) {
  ...
}
----

[source, java]
----
public MyClass(@ApplicationEventBus EventSource eventSource) {
  ...
}
----

[source, java]
----
public MyClass(@ApplicationEventBus EventBus eventBus) {
  ...
}
----

Having acquired the `EventHandler`, `EventSource` or `EventBus` instance that way, you can use it to emit event objects to it and/or subscribe to receive event objects.

Note that, within the Kernel application, event objects should be emitted via the kernel executor to avoid concurrency issues -- see <<section-kernel-executor>>.

=== Customizing and extending the kernel application

==== Guice modules for customizing the kernel application

The openTCS kernel application uses Guice to configure its components.
To modify the wiring of components within the application and to add your own components, you can register custom Guice modules.
Modules are found and registered automatically via `java.util.ServiceLoader`.

Basically, the following steps are required for customizing the application:

. Build a JAR file for your custom injection module with the following content:
.. A subclass of `org.opentcs.customizations.kernel.KernelInjectionModule`, which can be found in the base library, must be contained.
Configure your custom components or adjust the application's default wiring in this module.
`KernelInjectionModule` provides a few supporting methods you can use.
.. A plain text file named `META-INF/services/org.opentcs.customizations.kernel.KernelInjectionModule` must also be contained.
This file should contain a single line of text with the fully qualified class name of your module.
. Ensure that the JAR file(s) containing your Guice modules and the implementation of your custom component(s) are part of the class path when you start the kernel application.

For more information on how the automatic registration works, see the documentation of `java.util.ServiceLoader` in the Java class library.
For more information on how Guice works, see the Guice documentation.

==== Replacing default kernel components

The kernel application comes with default implementations for the dispatching, routing and scheduling components.
These default implementations allow the kernel to fulfil all of its responsibilities, but specific use cases might make it necessary to replace them with custom ones.
In such cases, they can be replaced with a custom Guice configuration.

For each of these components, `KernelInjectionModule` provides a convenience method for (re)binding the implementation.
To replace e.g. the default `Dispatcher` implementation, simply register a Guice module in which you call `bindDispatcher()`.
The module's implementation could look like this:

[source, java]
----
@Override
protected void configure() {
  configureSomeDispatcherDependencies();
  bindDispatcher(CustomDispatcher.class);
}
----

IMPORTANT: Note that all component implementations are bound as singletons.
This is important for the following reason:
Components may be injected and used at multiple places within the kernel application; at the same time, every component may also have to keep an internal state to do its work.
If they were not bound as singletons, a new instance would be created for every injection, each of them with their own, separate internal state.
Build custom components with that in mind, and implement their `initialize()` and `terminate()` methods appropriately!

==== Customizing transformation of data sent to / received from vehicles

For transforming data sent to / received from vehicles, the following interfaces in the openTCS API are used:

* A `MovementCommandTransformer` transforms ``MovementCommand``s before they are sent to the vehicle, e.g. to adjust coordinates in the ``Point``s it contains for the vehicle's coordinate system.
* An `IncomingPoseTransformer` transforms ``Pose``s received by the vehicle, e.g. to adjust coordinates for the plant model coordinate system.
* A `VehicleDataTransformerFactory` provides matching instances of `MovementCommandTransformer` and `IncomingPoseTransformer`.

To integrate your own transformation implementations, do the following:

. Create custom implementations of `MovementCommandTransformer` and `IncomingPoseTransformer` that perform the actual custom transformations.
. Create an implementation of `VehicleDataTransformerFactory` that provides instances of your transformer implementations.

image::transformer_classes.png[]

To make your factory implementation usable in the kernel, register it as a binding for `VehicleDataTransformerFactory` in your `KernelInjectionModule` implementation.
For example, the transformer factory the kernel already comes with is registered with the following line:

[source, java]
----
include::{kernel-guiceSrc}/org/opentcs/kernel/DefaultKernelInjectionModule.java[tags=documentation_registerTransformerFactory]
----

Finally, to select your transformer (factory) to be used for a specific vehicle, set a property on the vehicle element in the plant model with key `tcs:vehicleDataTransformer` to the value that your factory's `getName()` method provides.

==== Customizing allowed deviation for vehicle positions

When a vehicle reports its position not with a logical point name but as coordinates only, the openTCS kernel checks whether the reported position is within an allowed deviation from any known point in the plant model.
The allowed deviation can be set globally for all vehicles at all points via the kernel configuration -- see the reference documentation for configuration parameters in the User's Guide.
For more flexible and fine-grained control over the allowed deviation, you can integrate a custom implementation of the `PositionDeviationPolicy` and `PositionDeviationPolicyFactory` interfaces.
To do so, follow these steps:

. Create a custom implementation of `PositionDeviationPolicy` that implements the logic for determining the allowed deviation for a given vehicle and point.
It could e.g. read specific properties from the vehicle or point objects to determine the allowed deviation.
. Create an implementation of `PositionDeviationPolicyFactory` that provides instances of your `PositionDeviationPolicy` implementation.
It should return instances only for vehicles your factory is supposed to handle.
. Register your factory implementation as a binding for `PositionDeviationPolicyFactory` in your `KernelInjectionModule` implementation.
This would look like this:
+
[source, java]
----
@Override
protected void configure() {
  positionDeviationPolicyFactoryBinder()
      .addBinding()
      .to(MyPositionDeviationPolicyFactory.class);
}
----

IMPORTANT: Avoid registering multiple factories that provide policies for the same vehicle.
Which factory is used is undefined in that case.

==== Developing vehicle drivers

openTCS supports integration of custom vehicle drivers that implement vehicle-specific communication protocols and thus mediate between the kernel and the vehicle.
Due to its function, a vehicle driver is also called a communication adapter.
The following sections describe which requirements must be met by a driver and which steps are necessary to create and use it.

===== Classes and interfaces for the kernel

.Classes of a comm adapter implementation (kernel side)
image::commadapter_classes_kernel.png[]

When developing a vehicle driver, the most important classes and interfaces in the base library are the following:

* `VehicleCommAdapter` declares methods that every comm adapter must implement.
These methods are called by components within the kernel, for instance to tell a vehicle that it is supposed to move to the next position in the driving course.
Classes implementing this interface are expected to perform the actual communication with a vehicle, e.g. via TCP, UDP or some field bus.
* `BasicVehicleCommAdapter` is the recommended base class for implementing a `VehicleCommAdapter`.
It primarily provides some basic command queueing.
* `VehicleCommAdapterFactory` describes a factory for `VehicleCommAdapter` instances.
The kernel instantiates and uses one such factory per vehicle driver to create instances of the respective `VehicleCommAdapter` implementation on demand.
* A single `VehicleProcessModel` instance should be provided by every `VehicleCommAdapter` instance in which it keeps the relevant state of both the vehicle and the comm adapter.
This model instance is supposed to be updated to notify the kernel about relevant changes.
The comm adapter implementation should e.g. update the vehicle's current position in the model when it receives that information to allow the kernel and GUI frontends to use it.
Likewise, other components may set values that influence the comm adapter's behaviour in the model, e.g. a time interval for periodic messages the comm adapter sends to the vehicle.
`VehicleProcessModel` may be used as it is, as it contains members for all the information the openTCS kernel itself needs.
However, developers may use driver-specific subclasses of `VehicleProcessModel` to have the comm adapter and other components exchange more than the default set of attributes.

===== Classes and interfaces for the control center application

For the kernel control center application, the following interfaces and classes are the most important ones:

.Classes of a comm adapter implementation (kernel control center side)
image::commadapter_classes_kcc.png[]

* `VehicleCommAdapterPanel` instances may be created by a `VehicleCommAdapterPanelFactory` e.g. to display information about the associated vehicle or send low-level messages to it.
* `VehicleProcessModelTO` instances should be provided by every `VehicleCommAdapter` instance according to the current state of its `VehicleProcessModel`.
Instances of this model are supposed to be used in a comm adapter's `VehicleCommAdapterPanel` instances for updating their contents only.
Note that `VehicleProcessModelTO` is basically a serializable representation of a comm adapter's `VehicleProcessModel`.
Developers should keep that in mind when creating driver-specific subclasses of `VehicleProcessModelTO`.
* Instances of `VehicleCommAdapterDescription` provide a string describing/identifying the comm adapter implementation.
This string is shown e.g. when the user may select one of a set of driver implementations and should thus be unique.
It is also used for attaching a comm adapter implementation via `VehicleService.attachCommAdapter()`.
* `AdapterCommand` instances can be sent from a panel to a `VehicleCommAdapter` instance via `VehicleService.sendCommAdapterCommand()`.
They are supposed to be executed by the comm adapter and can be used to execute arbitrary methods, e.g. methods of the `VehicleCommAdapter` itself, or update contents of the comm adapter's `VehicleProcessModel`.
Note that `AdapterCommand` instances can only be sent to and processed by the kernel application if they are serializable and present in the kernel application's classpath.

===== Steps to create a new vehicle driver

. Create an implementation of `VehicleCommAdapter`:
.. Subclass `BasicVehicleCommAdapter` unless you have a reason not to.
You don't have to, but if you don't, you also need to implement command queue management yourself.
.. Implement the abstract methods of `BasicVehicleCommAdapter` in the derived class to realize communication with the vehicle.
.. In situations in which the state of the vehicle changes in a way that is relevant for the kernel or the comm adapter's custom panels, the comm adapter should call the respective methods on the model.
Most importantly, call `setVehiclePosition()` and `commandExecuted()` on the comm adapter's model when the controlled vehicle's reported state indicates that it has moved to a different position or that it has finished an order.
. Create an implementation of `VehicleCommAdapterFactory` that provides instances of your `VehicleCommAdapter` for given `Vehicle` objects.
. Optional: Create any number of implementations of `VehicleCommAdapterPanel` that the kernel control center application should display for the comm adapter.
Create and return instances of these panels in the `getPanelsFor()` method of your ``VehicleCommAdapterPanelFactory``s implementation.

See the API documentation for more details.
For an example, refer to the implementation of the loopback comm adapter for virtual vehicles in the openTCS source distribution.
(Note, however, that this implementation does not implement communication with any physical vehicle.)

===== Registering a vehicle driver with the kernel

. Create a Guice module for your vehicle driver by creating a subclass of `KernelInjectionModule`.
Implement the `configure()` method and register a binding to your `VehicleCommAdapterFactory`.
For example, the loopback driver that is part of the openTCS distribution registers its own factory class with the following line in its `configure()` method:
+
[source, java]
----
include::{loopback-guiceSrc}/org/opentcs/virtualvehicle/LoopbackCommAdapterModule.java[tags=documentation_createCommAdapterModule]
----

. In the JAR file containing your driver, ensure that there exists a folder named `META-INF/services/` with a file named `org.opentcs.customizations.kernel.KernelInjectionModule`.
This file should consist of a single line of text holding simply the name of the Guice module class, e.g.:
+
[source]
----
org.opentcs.virtualvehicle.LoopbackCommAdapterModule
----
NOTE: Background: openTCS uses `java.util.ServiceLoader` to automatically find Guice modules on startup, which depends on this file (with this name) being present.
See the JDK's API documentation for more information about how this mechanism works.
. Place the JAR file of your driver including all necessary resources in the subdirectory `lib/openTCS-extensions/` of the openTCS kernel application's installation directory _before_ the kernel is started.
(The openTCS start scripts include all JAR files in that directory in the application's classpath.)

Drivers meeting these requirements are found automatically when you start the kernel.

==== Sending messages to communication adapters

Sometimes it is required to have some influence on the behaviour of a communication adapter (and thus the vehicle it is associated with) directly from a kernel client - to send a special telegram to the vehicle, for instance.
For these cases, `VehicleService.sendCommAdapterMessage(TCSObjectReference<Vehicle>, VehicleCommAdapterMessage)` provides a one-way communication channel for a client to send a message object to a communication adapter currently associated with a vehicle.
A comm adapter implementing `processMessage(VehicleCommAdapterMessage)` may interpret message objects sent to it and react in an appropriate way.
Note that the adapter implementation may or may not be able to understand the message.

==== Acquiring data from communication adapters

For getting information from a communication adapter to a kernel client, there are the following ways:

Communication adapters may publish events via their `VehicleProcessModel` instance to emit information encapsulated in an event for any listeners registered with the kernel.
Apparently, listeners must already be registered before such an event is emitted by the communication adapter, or they will miss it.
To register a client as a listener, use `EventSource.subscribe()`.
You can get the `EventSource` instance used by the kernel through dependency injection by using the qualifier annotation `ApplicationEventBus`.

Alternatively, communication adapters may use their `VehicleProcessModel` to set properties in the corresponding `Vehicle` object.
Kernel clients may then retrieve the information from it:

[source, java]
----
include::{documentation-testSrc}/org/opentcs/documentation/developers_guide/ReceiveCommAdapterMessageTest.java[tags=documentation_receiveMessageFromVehicle, indent=0]
----

Communication adapters may also use their `VehicleProcessModel` to set properties in the corresponding `TransportOrder` object a vehicle is currently processing.
This basically works the same way as with the `Vehicle` object:

[source, java]
----
include::{documentation-testSrc}/org/opentcs/documentation/developers_guide/ReceiveCommAdapterMessageTest.java[tags=documentation_receiveMessageFromTransportOrder, indent=0]
----

Unlike information published via events, data stored as properties in `Vehicle` or `TransportOrder` objects can be retrieved at any time.

==== Developing peripheral drivers

In addition to vehicle drivers, openTCS supports the integration of custom peripheral drivers that implement peripheral-specific communication protocols and thus mediate between the kernel and the peripheral device.
In openTCS, a peripheral device is a device a vehicle may interact with along its route, e.g. an elevator or a fire door.
Due to its function, a peripheral driver is also called a peripheral communication adapter.
The following sections describe which requirements must be met by a driver and which steps are necessary to create and use it.

===== Classes and interfaces for the kernel

.Classes of a peripheral comm adapter implementation (kernel side)
image::peripheral_commadapter_classes_kernel.png[]

When developing a peripheral driver, the most important classes and interfaces in the base library are the following:

* `PeripheralCommAdapter` declares methods that every comm adapter must implement.
These methods are called by components within the kernel, for instance to tell a peripheral device that it is supposed to perform an operation, e.g. for an elevator to move to a specific floor.
Classes implementing this interface are expected to perform the actual communication with a peripheral device, e.g. via TCP, UDP or some field bus.
* `BasicPeripheralCommAdapter` is the recommended base class for implementing a `PeripheralCommAdapter`.
It primarily provides some basic event dispatching with regards to the `PeripheralProcessModel`.
* `PeripheralCommAdapterFactory` describes a factory for `PeripheralCommAdapter` instances.
The kernel instantiates and uses one such factory per peripheral driver to create instances of the respective `PeripheralCommAdapter` implementation on demand.
* A single `PeripheralProcessModel` instance should be provided by every `PeripheralCommAdapter` instance in which it keeps the relevant state of both the peripheral device and the comm adapter.
This model instance is supposed to be updated to notify the kernel about relevant changes.
The comm adapter implementation should e.g. update the peripheral device's current state in the model when it receives that information to allow the kernel and GUI frontends to use it.
`PeripheralProcessModel` may be used as it is, as it contains members for all the information the openTCS kernel itself needs.
However, developers may use driver-specific subclasses of `PeripheralProcessModel` to have the comm adapter and other components exchange more than the default set of attributes.

===== Classes and interfaces for the control center application

For the kernel control center application, the following classes and interfaces are the most important:

.Classes of a peripheral comm adapter implementation (kernel control center side)
image::peripheral_commadapter_classes_kcc.png[]

* `PeripheralCommAdapterPanel` instances may be created by a `PeripheralCommAdapterPanelFactory` e.g. to display information about the associated peripheral device or send low-level messages to it.
* `PeripheralProcessModel` instances are used in a comm adapter's `PeripheralCommAdapterPanel` instances for updating their contents.
In contrast to a `VehicleCommAdapter`, there is no class such as `PeripheralProcessModelTO`, since `PeripheralProcessModel` already implements the `Serializable` interface.
Developers should keep that in mind when creating driver-specific subclasses of `PeripheralProcessModel`.
* Instances of `PeripheralCommAdapterDescription` provide a string describing/identifying the comm adapter implementation.
This string is shown e.g. when the user may select one of a set of driver implementations and should thus be unique.
It is also used for attaching a comm adapter implementation via `PeripheralService.attachCommAdapter()`.
* `PeripheralAdapterCommand` instances can be sent from a panel to a `PeripheralCommAdapter` instance via `PeripheralService.sendCommAdapterCommand()`.
They are supposed to be executed by the comm adapter and can be used to execute arbitrary methods, e.g. methods of the `PeripheralCommAdapter` itself, or update contents of the comm adapter's `PeripheralProcessModel`.
Note that `PeripheralAdapterCommand` instances can only be sent to and processed by the kernel application if they are serializable and present in the kernel application's classpath.

===== Steps to create a new peripheral driver

. Create an implementation of `PeripheralCommAdapter`:
.. Subclass `BasicPeripheralCommAdapter` unless you have a reason not to.
.. Implement the abstract methods of `BasicPeripheralCommAdapter` in the derived class to realize communication with the peripheral device.
.. In situations in which the state of the peripheral device changes in a way that is relevant for the kernel or the comm adapter's custom panels, the comm adapter should call the respective methods on the model and publish a corresponding `PeripheralProcessModelEvent` via the kernel's `ApplicationEventBus`.
Most importantly, call `PeripheralJobCallback.peripheralJobFinished()` on the callback instance provided with `PeripheralCommAdapter.process()` when the controlled peripheral device's reported state indicates that it has finished a job.
. Create an implementation of `PeripheralCommAdapterFactory` that provides instances of your `PeripheralCommAdapter` for given `Location` objects.
. Optional: Create any number of implementations of `PeripheralCommAdapterPanel` that the kernel control center application should display for the comm adapter.
Create and return instances of these panels in the `getPanelsFor()` method of your ``PeripheralCommAdapterPanelFactory``s implementation.

See the API documentation for more details.
For an example, refer to the implementation of the loopback peripheral comm adapter for virtual peripheral devices in the openTCS source distribution.
(Note, however, that this implementation does not implement communication with any physical peripheral device.)

===== Registering a peripheral driver with the kernel

. Create a Guice module for your peripheral driver by creating a subclass of `KernelInjectionModule`.
Implement the `configure()` method and register a binding to your `PeripheralCommAdapterFactory`.
For example, the peripheral loopback driver that is part of the openTCS distribution registers its own factory class with the following line in its `configure()` method:
+
[source, java]
----
include::{peripheral-loopback-guiceSrc}/org/opentcs/commadapter/peripheral/loopback/LoopbackPeripheralKernelModule.java[tags=documentation_createCommAdapterModule]
----

. In the JAR file containing your driver, ensure that there exists a folder named `META-INF/services/` with a file named `org.opentcs.customizations.kernel.KernelInjectionModule`.
This file should consist of a single line of text holding simply the name of the Guice module class, e.g.:
+
[source]
----
org.opentcs.commadapter.peripheral.loopback.LoopbackPeripheralKernelModule
----
NOTE: Background: openTCS uses `java.util.ServiceLoader` to automatically find Guice modules on startup, which depends on this file (with this name) being present.
See the JDK's API documentation for more information about how this mechanism works.
. Place the JAR file of your driver including all neccessary resources in the subdirectory `lib/openTCS-extensions/` of the openTCS kernel application's installation directory _before_ the kernel is started.
(The openTCS start scripts include all JAR files in that directory in the application's classpath.)

Drivers meeting these requirements are found automatically when you start the kernel.

[#section-kernel-executor]
==== Executing code in kernel context

Within the kernel, concurrent modifications of the data model -- e.g. contents of the plant model or transport order properties -- need to be synchronized carefully.
Similar to e.g. the Swing framework's Event Dispatcher Thread, a single thread is used for executing one-shot or periodics tasks performing data modifications.
To help with this, an instance of `java.util.concurrent.ScheduledExecutorService` is provided.
Custom code running within the kernel application, including vehicle drivers and implementations of additional funcionality, should also perform changes of the data model via this executor only to avoid concurrency issues.

To make use of the kernel's executor, use the `@KernelExecutor` qualifier annotation and inject a `ScheduledExecutorService`:

[source, java]
----
@Inject
public MyClass(@KernelExecutor ScheduledExecutorService kernelExecutor) {
  ...
}
----

You can also inject it as a `java.util.concurrent.ExecutorService`:

[source, java]
----
@Inject
public MyClass(@KernelExecutor ExecutorService kernelExecutor) {
  ...
}
----

Injecting a `java.util.concurrent.Executor` is also possible:

[source, java]
----
@Inject
public MyClass(@KernelExecutor Executor kernelExecutor) {
  ...
}
----

Then, you can use it e.g. to lock a path in the plant model in kernel context:

[source, java]
----
kernelExecutor.submit(() -> routerService.updatePathLock(ref, true));
----

Due to the single-threaded nature of the kernel executor, tasks submitted to it are executed sequentially, one after another.
This implies that submitting long-running tasks should be avoided, as they would block the execution of subsequent tasks.

When event objects, e.g. instances of `TCSObjectEvent`, are distributed within the kernel, this always happens in kernel context, i.e. from a task that is run by the kernel executor.
Event handlers should behave accordingly and finish quickly/not block execution for too long.
If processing an event requires time-consuming actions to be taken, these should be executed on a different thread.

NOTE: As its name indicates, the kernel executor is only available within the kernel application.
It is not available for code running in other applications like the Operations Desk, and it is not required there (for avoiding concurrency issues in the kernel).

=== Customizing and extending the control center application

==== Guice modules for customizing the control center application

The openTCS kernel control center application uses Guice to configure its components.
To modify the wiring of components within the application and to add your own components, you can register custom Guice modules.
Modules are found and registered automatically via `java.util.ServiceLoader`.

Basically, the following steps are required for customizing the application:

. Build a JAR file for your custom injection module with the following content:
.. A subclass of `org.opentcs.customizations.controlcenter.ControlCenterInjectionModule` must be contained.
Configure your custom components or adjust the application's default wiring in this module.
`ControlCenterInjectionModule` provides a few supporting methods you can use.
.. A plain text file named `META-INF/services/org.opentcs.customizations.controlcenter.ControlCenterInjectionModule` must also be contained.
This file should contain a single line of text with the fully qualified class name of your module.
. Ensure that the JAR file(s) containing your Guice modules and the implementation of your custom component(s) are part of the class path when you start the control center application.

For more information on how the automatic registration works, see the documentation of `java.util.ServiceLoader` in the Java class library.
For more information on how Guice works, see the Guice documentation.

==== Registering driver panels with the control center

. Create a Guice module for your vehicle driver by creating a subclass of `ControlCenterInjectionModule`.
Implement the `configure()` method and register a binding to your `VehicleCommAdapterPanelFactory`.
The following example demonstrates how this module's `configure()` method looks like for the loopback driver that is part of the openTCS distribution:
+
[source, java]
----
include::{controlCenter-guiceSrc}/org/opentcs/kernelcontrolcenter/LoopbackCommAdapterPanelsModule.java[tags=documentation_createCommAdapterPanelsModule]
----

. In the JAR file containing your driver, ensure that there exists a folder named `META-INF/services/` with a file named `org.opentcs.customizations.controlcenter.ControlCenterInjectionModule`.
This file should consist of a single line of text holding simply the name of the Guice module class, e.g.:
+
[source]
----
org.opentcs.controlcenter.LoopbackCommAdapterPanelsModule
----
NOTE: Background: openTCS uses `java.util.ServiceLoader` to automatically find Guice modules on startup, which depends on this file (with this name) being present.
See the JDK's API documentation for more information about how this mechanism works.
. Place the JAR file of your driver including all neccessary resources in the subdirectory `lib/openTCS-extensions/` of the control center application's installation directory _before_ the application is started.
(The openTCS start scripts include all JAR files in that directory in the application's classpath.)

Panels meeting these requirements are found automatically when you start the kernel control center application.

==== How to change the window icon

To change the image that is used as the icon for the application window:

. Prepare custom icon files with the following names (the number at the end of the file name indicates the respective image's expected width and height in pixels):
** `custom_icon_016.png`
** `custom_icon_032.png`
** `custom_icon_064.png`
** `custom_icon_128.png`
** `custom_icon_256.png`
. Create a JAR file (with any name, e.g. `my-custom-icons.jar`) that contains the custom icon files in a folder named `/org/opentcs/util/gui/res/icons/`.
* Place the JAR file in the subdirectory `lib/` of the kernel control center application's installation directory _before_ the application is started.
(The openTCS start scripts include all JAR files in that directory in the application's classpath.)

Note that the default set of icons will be used if _any_ of the custom icons (as described above) could not be found.

=== Customizing and extending the Model Editor and the Operations Desk applications

NOTE: The process of customizing and extending the Model Editor and the Operations Desk is basically identical for both applications.
For the sake of simplicity, this section describes the process using the Operations Desk application as an example.
Where necessary, differences between the two applications are explicitly mentioned.

==== Guice modules for extending the Operations Desk application

Analogous to the kernel application, the Operations Desk application uses Guice to configure its components.
To modify the wiring of components within the application and to add your own components, you can register custom Guice modules.
Modules are found and registered automatically via `java.util.ServiceLoader`.

Basically, the following steps are required for customizing the application:

. Build a JAR file for your custom injection module with the following content:
.. A subclass of `PlantOverviewInjectionModule`, which can be found in the base library, must be contained.
Configure your custom components or adjust the application's default wiring in this module.
`PlantOverviewInjectionModule` provides a few supporting methods you can use.
.. A plain text file named `META-INF/services/org.opentcs.customizations.plantoverview.PlantOverviewInjectionModule` must also be contained.
This file should contain a single line of text with the fully qualified class name of your module.
. Ensure that the JAR file(s) containing your Guice modules and the implementation of your custom component(s) are part of the class path when you start the Operations Desk application.

For more information on how the automatic registration works, see the documentation of `java.util.ServiceLoader` in the Java class library.
For more information on how Guice works, see the Guice documentation.

==== How to add import/export functionality for plant model data

It is not uncommon for plant model data to be shared with other systems.
For instance, it is possible that the navigation computer of a vehicle already has detailed information about the plant environment such as important positions and connections between them.
Entering this data manually via the Model Editor application would be a tiresome and error-prone work.
To help relieve users from such work, the Model Editor supports integrating components for importing plant model data from external resources -- e.g. files in a foreign file format -- or exporting plant model data to such resources.

To integrate a model import component, do the following:

. Create a class that implements the interface `PlantModelImporter` and implement the methods declared by it:
.. In `importPlantModel()`, implement what is necessary to produce an instance of `PlantModelCreationTO` that describes the plant model.
The actual steps necessary here may vary depending on the source and the type of model data to be imported.
In most cases, however, the process will probably look like the following:
... Show a dialog for the user to select the file to be imported.
... Parse the content of the selected file according to its specific file format.
... Convert the parsed model data to instances of `PointCreationTO`, `PathCreationTO` etc., and fill a newly created `PlantModelCreationTO` instance with them.
... Return the `PlantModelCreationTO` instance.
.. `getDescription()` should return a short description for your importer, for instance "Import from XYZ course data file".
An entry with this text will be shown in the Model Editor's btn:[menu:File[Import plant model]] submenu, and clicking on this entry will result in your `importPlantModel()` implementation to be called.
. Create a Guice module for registering your `PlantModelImporter` with openTCS by subclassing `PlantOverviewInjectionModule`.
Implement the `configure()` method and add a binding to your `PlantModelImporter` using `plantModelImporterBinder()`.
. Build and package the `PlantModelImporter` and Guice module into a JAR file.
. In the JAR file, register the Guice module class as a service of type `PlantOverviewInjectionModule`.
To do that, ensure that the JAR file contains a folder named `META-INF/services/` with a file named `org.opentcs.customizations.plantoverview.PlantOverviewInjectionModule`.
This file should consist of a single line of text holding simply the name of the Guice module class.
(See <<How to create a plugin panel for the Operations Desk client>> for an example.)
. Place the JAR file in the Model Editor application's class path (subdirectory `lib/openTCS-extensions/` of the application's installation directory) and start the application.

To integrate a model _export_ component, you follow the same steps, but implement the interface `PlantModelExporter` instead of `PlantModelImporter`.

==== How to create a plugin panel for the Operations Desk client

The Operations Desk client offers to integrate custom panels providing project-specific functionality.

. Implement a subclass of `PluggablePanel`.
. Implement a `PluggablePanelFactory` that produces instances of your `PluggablePanel`.
+
NOTE: The `PluggablePanelFactory.providesPanel(state)` method is used to determine which `Kernel.State` a factory provides panels for.
For plugin panels that are intended to be used with the Model Editor application only, this method should return `true` for the kernel state `Kernel.State.MODELLING`.
For plugin panels that are intended to be used with the Operations Desk application only, this method should return `true` for the kernel state `Kernel.State.OPERATING`.
Otherwise the plugin panels won't be shown in the respective application.

. Create a Guice module for your `PluggablePanelFactory` by subclassing `PlantOverviewInjectionModule`.
Implement the `configure()` method and add a binding to your `PluggablePanelFactory` using `pluggablePanelFactoryBinder()`.
For example, the load generator panel that is part of the openTCS distribution is registered with the following line in its module's `configure()` method:
+
[source, java]
----
include::{loadGeneratorPanel-guiceSrc}/org/opentcs/guing/plugins/panels/loadgenerator/LoadGeneratorPanelModule.java[tags=documentation_createPluginPanelModule]
----

. Build and package the `PluggablePanel`, `PluggablePanelFactory` and Guice module into a JAR file.
. In the JAR file, register the Guice module class as a service of type `PlantOverviewInjectionModule`.
To do that, ensure that the JAR file contains a folder named `META-INF/services/` with a file named `org.opentcs.customizations.plantoverview.PlantOverviewInjectionModule`.
This file should consist of a single line of text holding simply the name of the Guice module class, e.g.:
+
[source]
----
org.opentcs.guing.plugins.panels.loadgenerator.LoadGeneratorPanelModule
----

. Place the JAR file in the Operations Desk application's class path (subdirectory `lib/openTCS-extensions/` of the application's installation directory) and start the application.

==== How to create a location/vehicle theme for openTCS

Locations and vehicles are visualized in the Operations Desk client using configurable themes.
To customize the appearance of locations and vehicles, new theme implementations can be created and integrated into the Operations Desk client.

. Create a new class which implements `LocationTheme` or `VehicleTheme`.
. Place the JAR file of your theme, containing all required resources, in the subdirectory `lib/openTCS-extensions/` of the openTCS Operations Desk application's installation directory _before_ the application is started.
(The openTCS start scripts include all JAR files in that directory in the application's classpath.)
. Set the `locationThemeClass` or `vehicleThemeClass` in the Operations Desk application's configuration file.

Vehicles or locations in plant models are then rendered using your custom theme.

==== How to change the window icon

To change the image that is used as the icon for the application window:

. Prepare custom icon files with the following names (the number at the end of the file name indicates the respective image's expected width and height in pixels):
** `custom_icon_016.png`
** `custom_icon_032.png`
** `custom_icon_064.png`
** `custom_icon_128.png`
** `custom_icon_256.png`
. Create a JAR file (with any name, e.g. `my-custom-icons.jar`) that contains the custom icon files in a folder named `/org/opentcs/util/gui/res/icons/`.
* Place the JAR file in the subdirectory `lib/` of the Model Editor application's and/or Operations Desk application's installation directory _before_ the application is started.
(The openTCS start scripts include all JAR files in that directory in the respective application's classpath.)

Note that the default set of icons will be used if _any_ of the custom icons (as described above) could not be found.

=== Application configuration

As described in the openTCS User's Guide, the openTCS Kernel, Kernel Control Center, Model Editor and Operations Desk applications read their configurations from properties files.
This functionality is provided by the link:https://github.com/gestalt-config/gestalt[gestalt] library.

==== Supplementing configuration sources using gestalt

It is possible to register additional configuration sources, e.g. for reading configuration data from network resources or files in different formats.
The mechanism provided by `java.util.ServiceLoader` is used for this.
The following steps are required for registering a configuration source:

. Build a JAR file with the following content:
.. An implementation of `org.opentcs.configuration.gestalt.SupplementaryConfigSource`.
This interface is part of the `opentcs-impl-configuration-gestalt` artifact, which must be on your project's classpath.
.. A plain text file named `META-INF/services/org.opentcs.configuration.gestalt.SupplementaryConfigSource`.
This file should contain a single line of text with the fully qualified class name of your implementation.
. Ensure that the JAR file is part of the classpath when you start the respective application.

It is possible to register multiple supplementary configuration sources this way.

The configuration entries provided by any registered supplementary configuration source may override configuration entries provided by the properties files that are read by default.
Note that the order in which these additional configuration sources are processed is unspecified.

For more information on how the automatic registration works, see the documentation of `java.util.ServiceLoader` in the Java class library.

=== Translating the user interfaces

Each openTCS application with a user interface is prepared for internationalization based on Java's `ResourceBundle` mechanism.
As a result, the applications can be configured to display texts in different languages, provided there is a translation in the form of resource bundle property files.
(How this configuration works is described in the User's Guide.)
The openTCS distribution itself comes with language files for the default language (English) and German.
Additional translations can be integrated primarily by adding JAR files containing property files to the class path.

The following sections explain how to create and integrate a new translation.

NOTE: Parts of the texts in the distribution may change between openTCS releases.
While this might not happen often, it still means that, when you update to a new version of openTCS, you may want to check whether your translations are still correct.
If there were textual changes in the openTCS distribution, you may need to update your language files.

==== Extracting default language files

To create a new translation pack for an application, you first need to know what texts to translate.
The best way to do this is to look at the existing language files in the openTCS distribution.
These are contained in the applications' JAR files (`opentcs-*.jar`), and are by convention kept in a common directory `/i18n/org/opentcs` inside these JAR files.

To start your translation work, extract all of the application's language files into a single directory first.
Since JAR files are really only ZIP files, this can be done using any ZIP utility you like.
As an example, to use `unzip` in a shell on a Linux system, issue the following command from the application's `lib/` directory:

----
unzip "opentcs-*.jar" "i18n/org/opentcs/*.properties"
----

Alternatively, to use link:https://7-zip.org/[7-Zip] in a shell on a Windows system, issue the following command from the application's `lib/` directory:

----
7z x -r "opentcs-*.jar" "i18n\org\opentcs\*.properties"
----

You will find the extracted language files in the `i18n/` directory, then.
For the Model Editor or Operations Desk application, an excerpt of that directory's contents would look similar to this:

....
i18n/
  org/
    opentcs/
      plantoverview/
        mainMenu.properties
        mainMenu_de.properties
        toolbar.properties
        toolbar_de.properties
        ...
....

Files whose names end with `_de.properties` are German translations.
You will not need these and can delete them.

==== Creating a translation

Copy the whole `i18n/` directory with the English language files to a new, separate directory, e.g. `translation/`.
Working with a copy ensures that you still have the English version at hand to look up the original texts when translating.

Then rename all property files in the new directory so their names contain the appropriate language tag for your translation.
If you are e.g. translating to Norwegian, rename `mainMenu.properties` to `mainMenu_no.properties` and the other files accordingly.
It is important that the base name of the file remains the same and only the language tag is added to it.

The next step is doing the actual translation work -- open each property file in a text editor and translate the properties' values in it.

After translating all the files, create a JAR file containing the `i18n/` directory with your language files.
You can do this for instance by simply creating a ZIP file and changing its name to end with `.jar`.

The result could be a file named e.g. `language-pack-norwegian.jar`, whose contents should look similar to this:

....
i18n/
  org/
    opentcs/
      plantoverview/
        mainMenu_no.properties
        toolbar_no.properties
        ...
....

==== Integrating a translation

Finally, you merely need to add the JAR file you created to the translated application's class path.
After configuring the application to the respective language and restarting it, you should see your translations in the user interface.

==== Updating a translation

As development of openTCS proceeds, parts of the applications' language files may change.
This means that your translations may also need to be updated when you move from one version of openTCS to a more recent one.

To find out what changes were made and may need to be applied to your translations, you could do the following:

. Extract the language files for the old version of the application, e.g. into a directory `translation_old/`.
. Extract the language files for the new version of the application, e.g. into a directory `translation_new/`.
. Create a link:https://en.wikipedia.org/wiki/Diff[diff] between the two language file versions.
For example, on a Linux system you could run `diff -urN translation_old/ translation_new/ > language_changes.diff` to write a diff to the file `language_changes.diff`.
. Read the diff to see which new language files and/or entries were added, removed or changed.

Based on the information from the diff, you can apply appropriate changes to your own language files.
Then you merely need to create new JAR files for your translations and add them to the applications' class paths.
