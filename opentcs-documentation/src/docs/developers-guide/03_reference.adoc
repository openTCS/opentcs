// SPDX-FileCopyrightText: The openTCS Authors
// SPDX-License-Identifier: CC-BY-4.0

== Reference

=== System requirements

The openTCS source code is written in Java.
To compile it, you need a Java Development Kit (JDK) 21.
To run the resulting binaries, you need a Java Runtime Environment (JRE) 21.
All other required libraries are included in the openTCS distribution or will be downloaded automatically when building it from source code.

=== Available artifacts and API compatibility

The openTCS project publishes artifacts for releases via the link:https://repo1.maven.org/maven2/[Maven Central] artifact repository, so you can easily integrate them with build systems such as Gradle or Maven.
In Gradle build scripts, for example, use something like the following to integrate an openTCS library:

[source, groovy, subs="attributes"]
----
repositories {
  mavenCentral()
}

dependencies {
  compile group: 'org.opentcs', name: '${ARTIFACT}', version: '{revnumber}'
}
----

Set the version number of the openTCS release you actually want to work with, and select the appropriate `${ARTIFACT}` name from the following table:

[cols="1,1,2", options="header"]
.Artifacts published by the openTCS project
|===

|Artifact name |API compatibility between minor releases |Content

|`opentcs-api-base`
|Yes
|The base API for clients and extensions.
This is what most developers probably want to use.

|`opentcs-api-injection`
|Yes
|API interfaces and classes used for dependency injection within the kernel and client applications.
This is required in integration projects customizing these applications, e.g. adding components like vehicle driver implementations.

|`opentcs-common`
|No
|A collection of utility classes used by openTCS components.

|`opentcs-impl-configuration-gestalt`
|No
|An implementation of the base API's configuration interfaces based on gestalt.

|`opentcs-kernel-extension-http-services`
|No
|A kernel extension providing the web API implementation.

|`opentcs-kernel-extension-rmi-services`
|No
|A kernel extension providing the RMI interface implementation.

|`opentcs-kernel-extension-statistics`
|No
|A kernel extension providing the statistics collection implementation.

|`opentcs-plantoverview-base`
|No
|The base data structures and components used by the Model Editor and the Operations Desk that don't require third-party libraries.

|`opentcs-plantoverview-common`
|No
|A collection of classes and components commonly used by the Model Editor and the Operations Desk.

|`opentcs-plantoverview-panel-loadgenerator`
|No
|The load generator panel implementation for the Operations Desk.

|`opentcs-plantoverview-panel-resourceallocation`
|No
|The resource allocation panel implemenation for the Operations Desk.

|`opentcs-plantoverview-panel-statistics`
|No
|The statistics panel implementation for the Operations Desk.

|`opentcs-plantoverview-themes-default`
|No
|The default themes implementation for the Operations Desk.

|`opentcs-commadapter-loopback`
|No
|A very basic vehicle driver simulating a virtual vehicle.

|`opentcs-strategies-default`
|No
|The default implementations of strategies that are used by the kernel application.

|`opentcs-kernel`
|No
|The kernel application.

|`opentcs-kernelcontrolcenter`
|No
|The Kernel Control Center application.

|`opentcs-modeleditor`
|No
|The Model Editor application.

|`opentcs-operationsdesk`
|No
|The Operations Desk application.

|===

Note that only the basic API libraries provide a documented API that the openTCS developers try to keep compatible between minor releases.
(For these libraries, the rules of https://semver.org/[semantic versioning] are applied.)
All other artifacts' contents can and will change regardless of any compatibility concerns, so if you explicitly use these as dependencies and switch to a different version of openTCS, you may have to adjust and recompile your code.

=== Third-party dependencies

The kernel and the client applications depend on the following external frameworks and libraries:

* SLF4J (https://www.slf4j.org/):
A simple logging facade to keep the actual logging implementation replaceable.
* Google Guice (https://github.com/google/guice):
A light-weight dependency injection framework.
* Gestalt (https://github.com/gestalt-config/gestalt):
A configuration library supporting binding interfaces.
* Google Guava (https://github.com/google/guava):
A collection of small helper classes and methods.

The kernel application also depends on the following libraries:

* JGraphT (https://jgrapht.org/):
A library for working with graphs and using algorithms on them.
* Spark (https://sparkjava.com/):
A framework for creating web applications.
* Jackson (https://github.com/FasterXML/jackson):
Provides JSON bindings for Java objects.

The Model Editor and Operations Desk applications have the following additional dependencies:

* JHotDraw (https://github.com/wrandelshofer/jhotdraw):
A framework for drawing graph structures (like driving course models).
* Docking Frames (https://www.docking-frames.org/):
A framework for docking and undocking of GUI panels

For automatic tests, the following dependencies are used:

* JUnit (https://junit.org/):
A simple unit-testing framework.
* Mockito (https://site.mockito.org/):
A framework for creating mock objects.
* Hamcrest (http://hamcrest.org/):
A framework for assertion matchers that can be used in tests.

The artifacts for these dependencies are downloaded automatically when building the applications.

=== Modularity and extensibility

The openTCS project heavily relies on link:https://github.com/google/guice[Guice] for dependency injection and wiring of components as well as for providing plugin-like extension mechanisms.
In the injection API, relevant classes can be found in the package `org.opentcs.customizations`.
For examples, see <<Customizing and extending the kernel application>>, <<Customizing and extending the Model Editor and the Operations Desk applications>> and <<Customizing and extending the control center application>>.

=== Logging

The code in the official openTCS distribution uses https://www.slf4j.org/[SLF4J] for logging.
Thus, the actual logging implementation is easily interchangeable by replacing the SLF4J binding in the respective application's classpath.
The kernel and client applications come with SLF4J's bindings for `java.util.logging` by default.
For more information on how to change the actual logging implementation, e.g. to use log4j, please see the SLF4J documentation.

=== openTCS kernel APIs

openTCS provides the following APIs to interact with the kernel:

* The kernel's Java API for both extending the kernel application as well as interfacing with it via RMI.
See <<section-kernel-api>> for details.
* A web API for interfacing with the kernel via HTTP calls.
See the separate interface documentation that is part of the openTCS distribution for details.

[#section-kernel-api]
=== The kernel's Java API

The interfaces and classes required to use the kernel API are part of the `opentcs-api-base` JAR file, so you should add that to your classpath/declare a dependency on it.
(See <<Available artifacts and API compatibility>>.)
The basic data structures for plant model components and transport orders you will encounter often are the following:

.Basic data structures
image::tcsobject_classes.png[]

The service interfaces that are most often interacted with to fetch and manipulate such data structures are these:

.TCSObject-related service interfaces
image::service_interfaces_tcsobjects.png[]

A few more interfaces are available to interact with various parts of the kernel, as shown in the following diagram:

.Additional service interfaces
image::service_interfaces_others.png[]

NOTE: _Peripheral*_ are classes/interfaces related to experimental integration of peripheral devices.
These features are not documented in detail, yet, and developers using any of them are on their own, for now.

=== Transport orders in openTCS

A transport order, represented by an instance of the class `TransportOrder`, describes a process to be executed by a vehicle.
Usually, this process is an actual transport of goods from one location to another.
A `TransportOrder` may, however, also just describe a vehicle's movement to a destination position and an optional vehicle operation to be performed.

All of the following are examples for "transport orders" in openTCS, even if nothing is actually being transported:

* A classic order for transporting goods from somewhere to somewhere else:
.. Move to location "A" and perform operation "Load cargo" there.
.. Move to location "B" and perform operation "Unload cargo" there.
* Manipulation of transported or stationary goods:
.. Move to location "A" and perform operation "Drill" there.
.. Move to location "B" and perform operation "Hammer" there.
* An order to move the vehicle to a parking position:
.. Move to point "Park 01" (without performing any specific operation).
* An order to recharge the vehicle's battery:
.. Move to location "Recharge station" and perform operation "Charge battery" there.

==== A transport order's life cycle

. When a transport order is created, its initial state is `RAW`.
. A user/client sets parameters for the transport order that are supposed to influence the transport process.
These parameters may be e.g. the transport order's deadline, the vehicle that is supposed to process the transport order or a set of generic, usually project-specific properties.
. The transport order is activated, i.e. parameter setup is finished.
Its state is set to `ACTIVE`.
. The kernel's router checks whether routing between the transport order's destinations is possible at all.
If yes, its state is changed to `DISPATCHABLE`.
If routing is not possible, the transport order is marked as `UNROUTABLE` and not processed any further.
. The kernel's dispatcher checks whether all requirements for executing the transport order are fulfilled and a vehicle is available for processing it.
As long as there are any requirements not yet fulfilled or no vehicle can execute it, the transport order is left waiting.
. The kernel's dispatcher assigns the transport order to a vehicle for processing.
Its state is changed to `BEING_PROCESSED`.
** If a transport order that is being processed is withdrawn (by a client/user), its state first changes to `WITHDRAWN` while the vehicle executes any orders that had already been sent to it.
Then the transport order's state changes to `FAILED`.
It is not processed any further.
** If processing of the transport order fails for any reason, it is marked as `FAILED` and not processed any further.
** If the vehicle successfully processes the transport order as a whole, it is marked as `FINISHED`.
. Eventually -- after a longer while or when too many transport orders in a final state have accumulated in the kernel's order pool -- the kernel removes the transport order.

The following state machine visualizes this life cycle:

.Transport order states
image::transportorder_states.png[]

==== Structure and processing of transport orders

.Transport order classes
image::transportorder_classes.png[]

A transport order is created by calling `TransportOrderService.createTransportOrder()`.
As its parameter, it expects an instance of `TransportOrderCreationTO` containing the sequence of destinations to visit and the operations a vehicle is supposed to perform there.
The kernel wraps each `Destination` in a newly-created `DriveOrder` instance.
These ``DriveOrder``s are themselves wrapped by the kernel in a single, newly-created `TransportOrder` instance in their given order.

Once a `TransportOrder` is being assigned to a vehicle by the `Dispatcher`, a `Route` is computed for each of its ``DriveOrder``s.
These ``Route``s are then stored in the corresponding ``DriveOrder``s.

image::transport_order_course.png[]

As soon as a vehicle (driver) is able to process a `DriveOrder`, the single ``Step``s of its `Route` are mapped to ``MovementCommand``s.
These ``MovementCommand``s contain all information the vehicle driver needs to reach the final destination and to perform the desired operation there.

.MovementCommand-related classes
image::movementcommand_classes.png[]

The ``MovementCommand``s for the partial routes to be travelled are sent to the vehicle driver bit by bit.
The kernel only sends as many ``MovementCommands``s in advance as is required for the vehicle driver to function properly.
It does this to maintain fine-grained control over the paths/resources used by all vehicles.
A vehicle driver may set the maximum number of ``MovementCommand``s it gets in advance by adjusting its command queue capacity.

As soon as a `DriveOrder` is finished, the `Route` of the next `DriveOrder` is mapped to ``MovementCommand``s.
Once the last `DriveOrder` of a `TransportOrder` is finished, the whole `TransportOrder` is finished, as well.
